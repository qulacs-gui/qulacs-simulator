/*! For license information please see 92afaf95-9917c1be193dfd5d.js.LICENSE.txt */
"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[749],{2732:function(e,t,n){n.d(t,{nY:function(){return Xs},Wh:function(){return Qs},cn:function(){return ei},nZ:function(){return ti},FV:function(){return oi},$P:function(){return ni},Zl:function(){return ri}});var o=n(2784),r=n(28316);var a=function(e){const t=new Error(e);if(void 0===t.stack)try{throw t}catch(e){}return t};var s=function(e){return!!e&&"function"==typeof e.then};var i=function(e,t){if(null!=e)return e;throw a(null!=t?t:"Got unexpected null or undefined")};function u(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class c{getValue(){throw a("BaseLoadable")}toPromise(){throw a("BaseLoadable")}valueMaybe(){throw a("BaseLoadable")}valueOrThrow(){throw a(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw a("BaseLoadable")}promiseOrThrow(){throw a(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw a("BaseLoadable")}errorOrThrow(){throw a(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw a("BaseLoadable")}}class l extends c{constructor(e){super(),u(this,"state","hasValue"),u(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{const t=e(this.contents);return s(t)?v(t):m(t)?t:h(t)}catch(t){return s(t)?v(t.next((()=>this.map(e)))):p(t)}}}class d extends c{constructor(e){super(),u(this,"state","hasError"),u(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}}class f extends c{constructor(e){super(),u(this,"state","loading"),u(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return v(this.contents.then((t=>{const n=e(t);if(m(n)){const e=n;switch(e.state){case"hasValue":case"loading":return e.contents;case"hasError":throw e.contents}}return n})).catch((t=>{if(s(t))return t.then((()=>this.map(e).contents));throw t})))}}function h(e){return Object.freeze(new l(e))}function p(e){return Object.freeze(new d(e))}function v(e){return Object.freeze(new f(e))}function y(e){const t=function(e){return e.every((e=>"hasValue"===e.state))?h(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?p(i(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):v(Promise.all(e.map((e=>e.contents))))}((Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))).map((e=>m(e)?e:s(e)?v(e):h(e))));return Array.isArray(e)?t:t.map((t=>Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})))}function m(e){return e instanceof c}const _={of:e=>s(e)?v(e):m(e)?e:h(e),error:e=>p(e),all:y,isLoadable:m};var S={loadableWithValue:h,loadableWithError:p,loadableWithPromise:v,loadableLoading:function(){return Object.freeze(new f(new Promise((()=>{}))))},loadableAll:y,isLoadable:m,RecoilLoadable:_},g=S.loadableWithValue,b=S.loadableWithError,T=S.loadableWithPromise,R=S.loadableLoading,w=S.loadableAll,A=S.isLoadable,E=S.RecoilLoadable,N=Object.freeze({__proto__:null,loadableWithValue:g,loadableWithError:b,loadableWithPromise:T,loadableLoading:R,loadableAll:w,isLoadable:A,RecoilLoadable:E});class k{constructor(e){u(this,"key",void 0),this.key=e}}class V extends k{}class L extends k{}var M={AbstractRecoilValue:k,RecoilState:V,RecoilValueReadOnly:L,isRecoilValue:function(e){return e instanceof V||e instanceof L}},C=M.AbstractRecoilValue,U=M.RecoilState,B=M.RecoilValueReadOnly,D=M.isRecoilValue,I=Object.freeze({__proto__:null,AbstractRecoilValue:C,RecoilState:U,RecoilValueReadOnly:B,isRecoilValue:D});var O=function(e,...t){0};const x=(new Map).set("recoil_hamt_2020",!0).set("recoil_sync_external_store",!0).set("recoil_suppress_rerender_in_callback",!0).set("recoil_memory_managament_2020",!0);function P(e){var t;return null!==(t=x.get(e))&&void 0!==t&&t}P.setPass=e=>{x.set(e,!0)},P.setFail=e=>{x.set(e,!1)},P.clear=()=>{x.clear()};var z=P;var F=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var W=function(e,t,{error:n}={}){return null};class ${}const j=new $;class G extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const H=new Map,q=new Map;class K extends Error{}const Z=new Map;function Y(e){return Z.get(e)}var J={nodes:H,recoilValues:q,registerNode:function(e){if(H.has(e.key)){e.key}H.set(e.key,e);const t=null==e.set?new I.RecoilValueReadOnly(e.key):new I.RecoilState(e.key);return q.set(e.key,t),t},getNode:function(e){const t=H.get(e);if(null==t)throw new K(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return H.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!z("recoil_memory_managament_2020"))return;const n=H.get(e);var o;null!=n&&null!==(t=n.shouldDeleteConfigOnRelease)&&void 0!==t&&t.call(n)&&(H.delete(e),null===(o=Y(e))||void 0===o||o(),Z.delete(e))},setConfigDeletionHandler:function(e,t){z("recoil_memory_managament_2020")&&(void 0===t?Z.delete(e):Z.set(e,t))},getConfigDeletionHandler:Y,recoilValuesForKeys:function(e){return F(e,(e=>i(q.get(e))))},NodeMissingError:K,DefaultValue:$,DEFAULT_VALUE:j,RecoilValueNotReady:G};var X={enqueueExecution:function(e,t){t()}};var Q,ee,te=(Q=function(e){var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,s=o/4,i={},u=function(e){return function(){return e}},c=n.hash=function(e){var n=void 0===e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var s=0;s<a;++s)r[s]=o[s]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,s=n;if(e)r=a=t;else for(s=new Array(o);r<t;)s[a++]=n[r++];for(++r;r<=o;)s[a++]=n[r++];return e&&(s.length=o),s},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:R}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:w}},S=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},g=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},b=function e(t,n,o,r,a,s){if(o===a)return _(t,o,[s,r]);var i=l(n,o),u=l(n,a);return S(t,d(i)|d(u),i===u?[e(t,n+5,o,r,a,s)]:i<u?[r,s]:[s,r])},T=function(e,t){return e===t.edit},R=function(e,t,n,o,r,a,s){if(t(a,this.key)){var u=o(this.value);return u===this.value?this:u===i?(--s.value,v):T(e,this)?(this.value=u,this):m(e,r,a,u)}var c=o();return c===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,c)))},w=function(e,t,n,o,r,a,s){if(r===this.hash){var u=function(e,t,n,o,r,a,s,u){for(var c=r.length,l=0;l<c;++l){var d=r[l];if(n(s,d.key)){var f=d.value,v=a(f);return v===f?r:v===i?(--u.value,p(e,l,r)):h(e,l,m(t,o,s,v),r)}}var y=a();return y===i?r:(++u.value,h(e,c,m(t,o,s,y),r))}(T(e,this),e,t,this.hash,this.children,o,a,s);return u===this.children?this:u.length>1?_(e,this.hash,u):u[0]}var c=o();return c===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,c)))},A=function(e,t,n,o,r,s,i){var u=this.mask,c=this.children,m=l(n,r),_=d(m),b=f(u,_),R=u&_,w=R?c[b]:v,A=w._modify(e,t,n+5,o,r,s,i);if(w===A)return this;var E,N=T(e,this),k=u,V=void 0;if(R&&y(A)){if(!(k&=~_))return v;if(c.length<=2&&((E=c[1^b])===v||1===E.type||2===E.type))return c[1^b];V=p(N,b,c)}else if(R||y(A))V=h(N,b,A,c);else{if(c.length>=a)return function(e,t,n,o,r){for(var a=[],s=o,i=0,u=0;s;++u)1&s&&(a[u]=r[i++]),s>>>=1;return a[t]=n,g(e,i+1,a)}(e,m,A,u,c);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var s=0,i=0,u=new Array(r+1);s<t;)u[i++]=o[s++];for(u[t]=n;s<r;)u[++i]=o[s++];return u}(N,b,A,c)}return N?(this.mask=k,this.children=V,this):S(e,k,V)},E=function(e,t,n,o,r,a,i){var u=this.size,c=this.children,d=l(n,r),f=c[d],p=(f||v)._modify(e,t,n+5,o,r,a,i);if(f===p)return this;var m=T(e,this),_=void 0;if(y(f)&&!y(p))++u,_=h(m,d,p,c);else if(!y(f)&&y(p)){if(--u<=s)return function(e,t,n,o){for(var r=new Array(t-1),a=0,s=0,i=0,u=o.length;i<u;++i)if(i!==n){var c=o[i];c&&!y(c)&&(r[a++]=c,s|=1<<i)}return S(e,s,r)}(e,u,d,c);_=h(m,d,v,c)}else _=h(m,d,p,c);return m?(this.size=u,this.children=_,this):g(e,u,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,s){var u=o();return u===i?v:(++s.value,m(e,r,a,u))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,s=o._config.keyEq;;)switch(r.type){case 1:return s(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var i=r.children,u=0,c=i.length;u<c;++u){var h=i[u];if(s(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(i,e,t,n)!==i};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var U=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||U,hash:e&&e.hash||c},v,0)},n.empty=n.make();var B=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return B(this)};var D=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return D(n,e,t,this)};var I=n.modify=function(e,t,n){return D(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return I(t,e,this)};var O=n.setHash=function(e,t,n,o){return D(u(n),e,t,o)};N.prototype.setHash=function(e,t,n){return O(e,t,n,this)};var x=n.set=function(e,t,n){return O(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return x(e,t,this)};var P=u(i),z=n.removeHash=function(e,t,n){return D(P,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var W=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return W(this)};var $=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return $(this)};var j=n.mutate=function(e,t){var n=W(t);return e(n),$(n)};N.prototype.mutate=function(e){return j(e,this)};var G=function(e){return e&&H(e[0],e[1],e[2],e[3],e[4])},H=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return q(a,o,[e,t,n,o,r])}return G(r)},q=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return H(o.length,o,0,t,n);default:return G(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=G(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var Y=function(e,t){return new Z(q(e._root,t))},J=function(e){return[e.key,e.value]},X=n.entries=function(e){return Y(e,J)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return X(this)};var Q=function(e){return e.key},ee=n.keys=function(e){return Y(e,Q)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return Y(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var s=0,i=a.length;s<i;){var u=a[s++];u&&u.type&&(1===u.type?t=e(t,u.value,u.key):r.push(u.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n},Q(ee={exports:{}},ee.exports),ee.exports);class ne{constructor(e){u(this,"_map",void 0),this._map=new Map(null==e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return re(this)}toMap(){return new Map(this._map)}}class oe{constructor(e){if(u(this,"_hamt",te.empty.beginMutation()),e instanceof oe){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return re(this)}toMap(){return new Map(this._hamt)}}function re(e){return z("recoil_hamt_2020")?new oe(e):new ne(e)}var ae=re,se=Object.freeze({__proto__:null,persistentMap:ae});var ie=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var ue=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function ce(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:ie(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);i(r.get(e)).add(t)})),a){ie(a,e).forEach((e=>{if(!r.has(e))return;const n=i(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var le={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),i(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:ue(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:ue(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=i(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,s;const i=t.getState();n!==i.currentTree.version&&n!==(null===(o=i.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=i.previousTree)||void 0===r?void 0:r.version)&&W("Tried to save dependencies to a discarded tree");const u=t.getGraph(n);if(ce(e,u),n===(null===(a=i.previousTree)||void 0===a?void 0:a.version)){ce(e,t.getGraph(i.currentTree.version),u)}if(n===(null===(s=i.previousTree)||void 0===s?void 0:s.version)||n===i.currentTree.version){var c;const n=null===(c=i.nextTree)||void 0===c?void 0:c.version;if(void 0!==n){ce(e,t.getGraph(n),u)}}}};let de=0;let fe=0;let he=0;var pe={getNextTreeStateVersion:()=>de++,getNextStoreID:()=>fe++,getNextComponentID:()=>he++};const{persistentMap:ve}=se,{graph:ye}=le,{getNextTreeStateVersion:me}=pe;function _e(){const e=me();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:ve(),nonvalidatedAtoms:ve()}}var Se={makeEmptyTreeState:_e,makeEmptyStoreState:function(){const e=_e();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,ye()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:me};class ge{}var be={RetentionZone:ge,retentionZone:function(){return new ge}};var Te={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var Re=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};var we=function(e,t){return new Proxy(e,{get:(e,n)=>(!(n in e)&&n in t&&(e[n]=t[n]()),e[n]),ownKeys:e=>Object.keys(e)})};const{getNode:Ae,getNodeMaybe:Ee,recoilValuesForKeys:Ne}=J,{RetentionZone:ke}=be,{setByAddingToSet:Ve}=Te,Le=Object.freeze(new Set);class Me extends Error{}function Ce(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Ae(n),s=function(e,t,n){if(!z("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof ke)r(n);else if(Array.isArray(n))for(const e of n)r(e);return()=>{if(!z("recoil_memory_managament_2020"))return;const{retention:o}=e.getState();function r(e){const n=o.nodesRetainedByZone.get(e);null==n||n.delete(t),n&&0===n.size&&o.nodesRetainedByZone.delete(e)}if(n instanceof ke)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),i=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{i(),s()}))}function Ue(e,t,n){return Ae(n).peek(e,t)}function Be(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let e=r.pop();e;e=r.pop()){var s;o.add(e);const t=null!==(s=a.nodeToNodeSubscriptions.get(e))&&void 0!==s?s:Le;for(const e of t)o.has(e)||r.push(e)}return o}var De,Ie,Oe,xe={getNodeLoadable:function(e,t,n){return Ce(e,t,n,"get"),Ae(n).get(e,t)},peekNodeLoadable:Ue,setNodeValue:function(e,t,n,o){const r=Ae(n);if(null==r.set)throw new Me(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Ce(e,t,n,"set"),a(e,t,o)},initializeNode:function(e,t,n){Ce(e,e.getState().currentTree,t,n)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=Ee(t);return null==r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:Ve(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=Ae(n).nodeType;return we({type:a},{loadable:()=>Ue(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>"selector"!==a&&t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var e;return Ne(null!==(e=r.nodeDeps.get(n))&&void 0!==e?e:[])},subscribers:()=>{var r,a;return{nodes:Ne(Re(Be(e,t,new Set([n])),(e=>e!==n))),components:F(null!==(r=null===(a=o.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}})},getDownstreamNodes:Be};const Pe=null!==(De=o.createMutableSource)&&void 0!==De?De:o.unstable_createMutableSource,ze=null!==(Ie=o.useMutableSource)&&void 0!==Ie?Ie:o.unstable_useMutableSource,Fe=null!==(Oe=o.useSyncExternalStore)&&void 0!==Oe?Oe:o.unstable_useSyncExternalStore;var We={createMutableSource:Pe,useMutableSource:ze,useSyncExternalStore:Fe,reactMode:function(){return z("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:z("recoil_sync_external_store")&&null!=Fe?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:z("recoil_mutable_source")&&null!=ze&&"undefined"!=typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?z("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:z("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}};const{getDownstreamNodes:$e,getNodeLoadable:je,setNodeValue:Ge}=xe,{getNextComponentID:He}=pe,{getNode:qe,getNodeMaybe:Ke}=J,{DefaultValue:Ze,RecoilValueNotReady:Ye}=J,{reactMode:Je}=We,{AbstractRecoilValue:Xe,RecoilState:Qe,RecoilValueReadOnly:et,isRecoilValue:tt}=I;function nt(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"==typeof o){const r=je(e,t,n);if("loading"===r.state)throw new Ye(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),s=Ge(e,t,o.key,a);for(const[e,n]of s.entries())ot(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;ot(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=Ke(e);null==a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else W(`Unknown action ${n.type}`)}function ot(e,t,n){"hasValue"===n.state&&n.contents instanceof Ze?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function rt(e,t){e.replaceState((n=>{const o=it(n);for(const n of t)nt(e,o,n);return ut(e,o),o}))}function at(e,t){if(st.length){const n=st[st.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else rt(e,[t])}const st=[];function it(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function ut(e,t){const n=$e(e,t,t.dirtyAtoms);for(const e of n){var o,r;null===(o=Ke(e))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function ct(e,t,n){at(e,{type:"set",recoilValue:t,valueOrUpdater:n})}var lt={RecoilValueReadOnly:et,AbstractRecoilValue:Xe,RecoilState:Qe,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&W("Tried to read from a discarded tree");const s=je(e,n,t);return"loading"===s.state&&s.contents.catch((()=>{})),s},setRecoilValue:ct,setRecoilValueLoadable:function(e,t,n){if(n instanceof Ze)return ct(e,t,n);at(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){at(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){at(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=He(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),i(a.nodeToComponentSubscriptions.get(t)).set(r,[null!=o?o:"<not captured>",n]);const s=Je();if(s.early&&("LEGACY"===s.mode||"MUTABLE_SOURCE"===s.mode)){const o=e.getState().nextTree;o&&o.dirtyAtoms.has(t)&&n(o)}return{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):W(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:tt,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof Ze?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return st.push(e),()=>{for(const[t,n]of e)rt(t,n);st.pop()!==e&&W("Incorrect order of batch popping")}},writeLoadableToTreeState:ot,invalidateDownstreams:ut,copyTreeState:it,refreshRecoilValue:function(e,t){var n;const{currentTree:o}=e.getState(),r=qe(t.key);null===(n=r.clearCache)||void 0===n||n.call(r,e,o)},invalidateDownstreams_FOR_TESTING:ut};var dt=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:ft}=xe,{deleteNodeConfigIfPossible:ht,getNode:pt}=J,{RetentionZone:vt}=be,yt=new Set;function mt(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void W("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const e of t)if(e instanceof vt)for(const t of St(n,e))r.add(t);else r.add(e);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return u(t),a;function u(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),s=[],u=new Set;for(;n.size>0;)c(i(n.values().next().value));return s;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(u.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const e of t)c(e);u.add(e),n.delete(e),s.push(e)}}(e,o,t,a,s);for(const e of l){var d;if("recoilRoot"===pt(e).retainedBy){s.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){s.add(e);continue}if(gt(e).some((e=>n.retention.referenceCounts.get(e)))){s.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&dt(t,(e=>s.has(e)))?s.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:yt){var h;a.has(t)||f.add(t)}f.size&&u(f)}}(e,r);for(const t of a)_t(e,o,t)}function _t(e,t,n){if(!z("recoil_memory_managament_2020"))return;ft(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=gt(n);for(const e of r){var a;null===(a=o.retention.nodesRetainedByZone.get(e))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const e=s.nodeDeps.get(n);if(void 0!==e){s.nodeDeps.delete(n);for(const t of e){var i;null===(i=s.nodeToNodeSubscriptions.get(t))||void 0===i||i.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}ht(n)}function St(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:yt}function gt(e){const t=pt(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof vt?[t]:t}function bt(e,t){if(!z("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):mt(e,new Set([t]))}(e,t)}var Tt={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var o;if(!z("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?bt(e,t):r.set(t,a)},updateRetainCountToZero:bt,releaseScheduledRetainablesNow:function(e){if(!z("recoil_memory_managament_2020"))return;const t=e.getState();mt(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};const{unstable_batchedUpdates:Rt}=r;var wt={unstable_batchedUpdates:Rt};const{unstable_batchedUpdates:At}=wt;var Et={unstable_batchedUpdates:At};const{batchStart:Nt}=lt,{unstable_batchedUpdates:kt}=Et;let Vt=kt;var Lt={getBatcher:()=>Vt,setBatcher:e=>{Vt=e},batchUpdates:e=>{Vt((()=>{let t=()=>{};try{t=Nt(),e()}finally{t()}}))}};var Mt=function*(e){for(const t of e)for(const e of t)yield e};var Ct={isSSR:"undefined"==typeof window,isReactNative:"undefined"!=typeof navigator&&"ReactNative"===navigator.product};var Ut={memoizeWithArgsHash:function(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e.apply(this,o)),n[r]}},memoizeOneWithArgsHash:function(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e.apply(this,r)),o}},memoizeOneWithArgsHashAndInvalidation:function(e,t){let n,o;return[(...r)=>{const a=t(...r);return n===a||(n=a,o=e.apply(this,r)),o},()=>{n=null}]}};const{batchUpdates:Bt}=Lt,{initializeNode:Dt,peekNodeInfo:It}=xe,{graph:Ot}=le,{getNextStoreID:xt}=pe,{DEFAULT_VALUE:Pt,recoilValues:zt,recoilValuesForKeys:Ft}=J,{AbstractRecoilValue:Wt,getRecoilValueAsLoadable:$t,setRecoilValue:jt,setUnvalidatedRecoilValue:Gt}=lt,{updateRetainCount:Ht}=Tt,{getNextTreeStateVersion:qt,makeEmptyStoreState:Kt}=Se,{isSSR:Zt}=Ct,{memoizeOneWithArgsHashAndInvalidation:Yt}=Ut;class Jt{constructor(e){u(this,"_store",void 0),u(this,"_refCount",1),u(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),$t(this._store,e)))),u(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),u(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null==e?void 0:e.isModified)){if(!1===(null==e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return Ft(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null==e?void 0:e.isInitialized)?zt.values():!0===e.isInitialized?Ft(Mt([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Re(zt.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),u(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),It(this._store,this._store.getState().currentTree,e)))),u(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new tn(this,Bt);return e(t),t})),u(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new tn(this,Bt);return t.retain(),await e(t),t.autoRelease_INTERNAL(),t})),this._store={storeID:xt(),getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return i(n.get(t));const o=Ot();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw a("Cannot subscribe to Snapshots")}};for(const e of this._store.getState().knownAtoms)Dt(this._store,e,"get"),Ht(this._store,e,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&W("Attempt to retain() Snapshot that was already released."),this._refCount++;let e=!1;return()=>{e||(e=!0,this._release())}}autoRelease_INTERNAL(){Zt||window.setTimeout((()=>this._release()),0)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach((e=>e())),this._store.getState().nodeCleanupFunctions.clear(),!z("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){z("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function Xt(e,t,n=!1){const o=e.getState(),r=n?qt():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(F(o.nodeCleanupFunctions.entries(),(([e])=>[e,()=>{}])))}}const[Qt,en]=Yt(((e,t)=>{const n=e.getState(),o="current"===t?n.currentTree:i(n.previousTree);return new Jt(Xt(e,o))}),((e,t)=>{var n;return String(t)+String(e.storeID)+String(e.getState().currentTree.version)+String(null===(n=e.getState().previousTree)||void 0===n?void 0:n.version)}));class tn extends Jt{constructor(e,t){super(Xt(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),u(this,"_batch",void 0),u(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();this._batch((()=>{Ht(n,e.key,1),jt(this.getStore_INTERNAL(),e,t)}))})),u(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();this._batch((()=>{Ht(t,e.key,1),jt(this.getStore_INTERNAL(),e,Pt)}))})),u(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();Bt((()=>{for(const[n,o]of e.entries())Ht(t,n,1),Gt(t,new Wt(n),o)}))})),this._batch=t}}var nn={Snapshot:Jt,MutableSnapshot:tn,freshSnapshot:function(e){const t=new Jt(Kt());return null!=e?t.map(e):t},cloneSnapshot:function(e,t="current"){const n=Qt(e,t);return n.isRetained()?n:(en(),Qt(e,t))}},on=nn.Snapshot,rn=nn.MutableSnapshot,an=nn.freshSnapshot,sn=nn.cloneSnapshot,un=Object.freeze({__proto__:null,Snapshot:on,MutableSnapshot:rn,freshSnapshot:an,cloneSnapshot:sn});var cn=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};const{useRef:ln}=o;var dn=function(e){const t=ln(e);return t.current===e&&"function"==typeof e&&(t.current=e()),t};const{getNextTreeStateVersion:fn,makeEmptyStoreState:hn}=Se,{cleanUpNode:pn,getDownstreamNodes:vn,initializeNode:yn,setNodeValue:mn,setUnvalidatedAtomValue_DEPRECATED:_n}=xe,{graph:Sn}=le,{cloneGraph:gn}=le,{getNextStoreID:bn}=pe,{createMutableSource:Tn,reactMode:Rn}=We,{applyAtomValueWrites:wn}=lt,{releaseScheduledRetainablesNow:An}=Tt,{freshSnapshot:En}=un,{useCallback:Nn,useContext:kn,useEffect:Vn,useMemo:Ln,useRef:Mn,useState:Cn}=o;function Un(){throw a("This component must be used inside a <RecoilRoot> component.")}const Bn=Object.freeze({storeID:bn(),getState:Un,replaceState:Un,getGraph:Un,subscribeToTransactions:Un,addTransactionMetadata:Un});let Dn=!1;function In(e){if(Dn)throw a("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){z("recoil_memory_managament_2020")&&z("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&An(e);const n=t.currentTree.version,o=fn();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,gn(i(t.graphsByVersion.get(n))))}}const On=o.createContext({current:Bn}),xn=()=>kn(On),Pn=o.createContext(null);function zn(e,t,n){const o=vn(e,n,n.dirtyAtoms);for(const e of o){const o=t.nodeToComponentSubscriptions.get(e);if(o)for(const[e,[t,r]]of o)r(n)}}function Fn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,n]of r)n(e);for(const[n,o]of t.transactionSubscriptions)o(e);(!Rn().early||t.suspendedComponentResolvers.size>0)&&(zn(e,t,n),t.suspendedComponentResolvers.forEach((e=>e())),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Wn({setNotifyBatcherOfChange:e}){const t=xn(),[,n]=Cn([]);return e((()=>n({}))),Vn((()=>(e((()=>n({}))),()=>{e((()=>{}))})),[e]),Vn((()=>{X.enqueueExecution("Batcher",(()=>{!function(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(null===n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Fn(e),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):W("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,z("recoil_memory_managament_2020")&&An(e)}finally{t.commitDepth--}}(t.current)}))})),null}let $n=0;function jn({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:r}){let a;const s=e=>{const t=a.current.graphsByVersion;if(t.has(e))return i(t.get(e));const n=Sn();return t.set(e,n),n},u=(e,t)=>{if(null==t){const{transactionSubscriptions:t}=h.current.getState(),n=$n++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=h.current.getState();n.has(t)||n.set(t,new Map);const o=$n++;return i(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},c=e=>{In(h.current);for(const t of Object.keys(e))i(h.current.getState().nextTree).transactionMetadata[t]=e[t]},l=e=>{In(h.current);const t=i(a.current.nextTree);let n;try{Dn=!0,n=e(t)}finally{Dn=!1}n!==t&&(a.current.nextTree=n,Rn().early&&zn(h.current,a.current,n),i(d.current)())},d=Mn(null),f=Nn((e=>{d.current=e}),[d]),h=dn((()=>null!=n?n:{storeID:bn(),getState:()=>a.current,replaceState:l,getGraph:s,subscribeToTransactions:u,addTransactionMetadata:c}));null!=n&&(h.current=n),a=dn((()=>null!=e?function(e,t){const n=hn();return t({set:(t,o)=>{const r=n.currentTree,a=mn(e,r,t.key,o),s=new Set(a.keys()),i=r.nonvalidatedAtoms.clone();for(const e of s)i.delete(e);n.currentTree={...r,dirtyAtoms:cn(r.dirtyAtoms,s),atomValues:wn(r.atomValues,a),nonvalidatedAtoms:i}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=_n(n.currentTree,t,e)}))}}),n}(h.current,e):null!=t?function(e){const t=En().map(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach((e=>e())),n.nodeCleanupFunctions.clear(),n}(t):hn()));const p=Ln((()=>null==Tn?void 0:Tn(a,(()=>a.current.currentTree.version))),[a]);return Vn((()=>{const e=h.current;for(const t of new Set(e.getState().knownAtoms))yn(e,t,"get");return()=>{for(const t of e.getState().knownAtoms)pn(e,t)}}),[h]),o.createElement(On.Provider,{value:h},o.createElement(Pn.Provider,{value:p},o.createElement(Wn,{setNotifyBatcherOfChange:f}),r))}var Gn={RecoilRoot:function(e){const{override:t,...n}=e,r=xn();return!1===t&&r.current!==Bn?e.children:o.createElement(jn,n)},useStoreRef:xn,useRecoilMutableSource:function(){const e=kn(Pn);return null==e&&O("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},useRecoilStoreID:function(){return xn().current.storeID},notifyComponents_FOR_TESTING:zn,sendEndOfBatchNotifications_FOR_TESTING:Fn};var Hn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useEffect:qn,useRef:Kn}=o;var Zn=function(e){const t=Kn();return qn((()=>{t.current=e})),t.current};const{useStoreRef:Yn}=Gn,{SUSPENSE_TIMEOUT_MS:Jn}=Tt,{updateRetainCount:Xn}=Tt,{RetentionZone:Qn}=be,{useEffect:eo,useRef:to}=o,{isSSR:no}=Ct;var oo=function(e){if(z("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof Qn?e:e.key)),n=Yn();eo((()=>{if(!z("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!no)window.clearTimeout(o.current),o.current=null;else for(const n of t)Xn(e,n,1);return()=>{for(const n of t)Xn(e,n,-1)}}),[n,...t]);const o=to(),r=Zn(t);if(!(no||void 0!==r&&Hn(r,t))){const e=n.current;for(const n of t)Xn(e,n,1);if(r)for(const t of r)Xn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)Xn(e,n,-1)}),Jn)}}(e)};const{useRef:ro}=o;var ao=function(){return ro(),"<component name not available>"};const{batchUpdates:so}=Lt,{DEFAULT_VALUE:io}=J,{reactMode:uo,useMutableSource:co,useSyncExternalStore:lo}=We,{useRecoilMutableSource:fo,useStoreRef:ho}=Gn,{isRecoilValue:po}=I,{AbstractRecoilValue:vo,getRecoilValueAsLoadable:yo,setRecoilValue:mo,setUnvalidatedRecoilValue:_o,subscribeToRecoilValue:So}=lt,{useCallback:go,useEffect:bo,useMemo:To,useRef:Ro,useState:wo}=o,{setByAddingToSet:Ao}=Te;function Eo(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:a(`Invalid value of loadable atom "${t.key}"`)}function No(e){const t=ho(),n=ao(),o=go((()=>{var n;const o=t.current,r=o.getState(),a=uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return{loadable:yo(o,e,a),key:e.key}}),[t,e]),r=go((e=>{let t;return()=>{var n,o;const r=e();return null!==(n=t)&&void 0!==n&&n.loadable.is(r.loadable)&&(null===(o=t)||void 0===o?void 0:o.key)===r.key?t:(t=r,r)}}),[]),a=To((()=>r(o)),[o,r]),s=go((o=>{const r=t.current;return So(r,e,o,n).release}),[t,e,n]);return lo(s,a,a).loadable}function ko(e){const t=ho(),n=go((()=>{var n;const o=t.current,r=o.getState(),a=uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return yo(o,e,a)}),[t,e]),o=go((()=>n()),[n]),r=ao(),s=go(((o,a)=>{const s=t.current;return So(s,e,(()=>{if(!z("recoil_suppress_rerender_in_callback"))return a();const e=n();c.current.is(e)||a(),c.current=e}),r).release}),[t,e,r,n]),i=fo();if(null==i)throw a("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const u=co(i,o,s),c=Ro(u);return bo((()=>{c.current=u})),u}function Vo(e){const t=ho(),n=ao(),o=go((()=>{var n;const o=t.current,r=o.getState(),a=uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return yo(o,e,a)}),[t,e]),r=go((()=>({loadable:o(),key:e.key})),[o,e.key]),a=go((e=>{const t=r();return e.loadable.is(t.loadable)&&e.key===t.key?e:t}),[r]);bo((()=>{const o=So(t.current,e,(e=>{i(a)}),n);return i(a),o.release}),[n,e,t,a]);const[s,i]=wo(r);return s.key!==e.key?r().loadable:s.loadable}function Lo(e){const t=ho(),[,n]=wo([]),o=ao(),r=go((()=>{var n;const o=t.current,r=o.getState(),a=uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return yo(o,e,a)}),[t,e]),a=r(),s=Ro(a);return bo((()=>{s.current=a})),bo((()=>{const a=t.current,i=a.getState(),u=So(a,e,(e=>{var t;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const o=r();null!==(t=s.current)&&void 0!==t&&t.is(o)||n(o),s.current=o}),o);if(i.nextTree)a.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{s.current=null,n([])}));else{var c;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const e=r();null!==(c=s.current)&&void 0!==c&&c.is(e)||n(e),s.current=e}return u.release}),[o,r,e,t]),a}function Mo(e){return z("recoil_memory_managament_2020")&&oo(e),{TRANSITION_SUPPORT:Vo,SYNC_EXTERNAL_STORE:No,MUTABLE_SOURCE:ko,LEGACY:Lo}[uo().mode](e)}function Co(e){const t=ho();return Eo(Mo(e),e,t)}function Uo(e){const t=ho();return go((n=>{mo(t.current,e,n)}),[t,e])}function Bo(e){return z("recoil_memory_managament_2020")&&oo(e),Vo(e)}function Do(e){const t=ho();return Eo(Bo(e),e,t)}var Io={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){const e=ao(),t=ho(),[,n]=wo([]),o=Ro(new Set);o.current=new Set;const r=Ro(new Set),a=Ro(new Map),s=go((e=>{const t=a.current.get(e);t&&(t.release(),a.current.delete(e))}),[a]),i=go(((e,t)=>{a.current.has(t)&&n([])}),[]);return bo((()=>{const n=t.current;ie(o.current,r.current).forEach((t=>{if(a.current.has(t))return void O(`Double subscription to RecoilValue "${t}"`);const o=So(n,new vo(t),(e=>i(e,t)),e);a.current.set(t,o);n.getState().nextTree?n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{i(n.getState(),t)})):i(n.getState(),t)})),ie(r.current,o.current).forEach((e=>{s(e)})),r.current=o.current})),bo((()=>{const n=a.current;return ie(o.current,new Set(n.keys())).forEach((o=>{const r=So(t.current,new vo(o),(e=>i(e,o)),e);n.set(o,r)})),()=>n.forEach(((e,t)=>s(t)))}),[e,t,s,i]),To((()=>{function e(e){return n=>{mo(t.current,e,n)}}function n(e){var n;o.current.has(e.key)||(o.current=Ao(o.current,e.key));const r=t.current.getState();return yo(t.current,e,uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree)}function r(e){return Eo(n(e),e,t)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(t){return[r(t),e(t)]},getRecoilStateLoadable:function(t){return[n(t),e(t)]},getSetRecoilState:e,getResetRecoilState:function(e){return()=>mo(t.current,e,io)}}}),[o,t])},useRecoilState:function(e){return[Co(e),Uo(e)]},useRecoilStateLoadable:function(e){return[Mo(e),Uo(e)]},useRecoilValue:Co,useRecoilValueLoadable:Mo,useResetRecoilState:function(e){const t=ho();return go((()=>{mo(t.current,e,io)}),[t,e])},useSetRecoilState:Uo,useSetUnvalidatedAtomValues:function(){const e=ho();return(t,n={})=>{so((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>_o(e.current,new vo(n),t)))}))}},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Bo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Do,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:function(e){return[Do(e),Uo(e)]}};var Oo=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var xo=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var Po=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const{batchUpdates:zo}=Lt,{DEFAULT_VALUE:Fo,getNode:Wo,nodes:$o}=J,{useStoreRef:jo}=Gn,{AbstractRecoilValue:Go,setRecoilValueLoadable:Ho}=lt,{SUSPENSE_TIMEOUT_MS:qo}=Tt,{cloneSnapshot:Ko}=un,{useCallback:Zo,useEffect:Yo,useRef:Jo,useState:Xo}=o,{isSSR:Qo}=Ct;function er(e){const t=jo();Yo((()=>t.current.subscribeToTransactions(e).release),[e,t])}function tr(e){const t=e.atomValues.toMap(),n=ue(Oo(t,((e,t)=>{const n=Wo(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return Po(e.nonvalidatedAtoms.toMap(),n)}function nr(e,t){var n;const o=e.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;zo((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,s;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(s=a.atomValues.get(t))||void 0===s?void 0:s.contents)&&Wo(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{Ho(e,new Go(t),a.atomValues.has(t)?i(a.atomValues.get(t)):Fo)})),e.replaceState((e=>({...e,stateID:t.getID()})))}))}var or={useRecoilSnapshot:function(){const e=jo(),[t,n]=Xo((()=>Ko(e.current))),o=Zn(t),r=Jo(),a=Jo();if(er(Zo((e=>n(Ko(e))),[])),Yo((()=>{const e=t.retain();var n;r.current&&!Qo&&(window.clearTimeout(r.current),r.current=null,null===(n=a.current)||void 0===n||n.call(a),a.current=null);return e}),[t]),o!==t&&!Qo){var s;if(r.current)window.clearTimeout(r.current),r.current=null,null===(s=a.current)||void 0===s||s.call(a),a.current=null;a.current=t.retain(),r.current=window.setTimeout((()=>{var e;r.current=null,null===(e=a.current)||void 0===e||e.call(a),a.current=null}),qo)}return t},gotoSnapshot:nr,useGotoRecoilSnapshot:function(){const e=jo();return Zo((t=>nr(e.current,t)),[e])},useRecoilTransactionObserver:function(e){er(Zo((t=>{const n=Ko(t,"current"),o=Ko(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useTransactionObservation_DEPRECATED:function(e){er(Zo((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(W("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=tr(o),a=tr(n),s=ue($o,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),i=xo(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:er};const{peekNodeInfo:rr}=xe,{useStoreRef:ar}=Gn;var sr=function(){const e=ar();return({key:t})=>rr(e.current,e.current.getState().currentTree,t)};const{reactMode:ir}=We,{RecoilRoot:ur,useStoreRef:cr}=Gn,{useMemo:lr}=o;var dr=function(){ir().mode;const e=cr().current;return lr((()=>function({children:t}){return o.createElement(ur,{store_INTERNAL:e},t)}),[e])};const{loadableWithValue:fr}=N,{initializeNode:hr}=xe,{DEFAULT_VALUE:pr,getNode:vr}=J,{copyTreeState:yr,getRecoilValueAsLoadable:mr,invalidateDownstreams:_r,writeLoadableToTreeState:Sr}=lt;function gr(e){return"atom"===vr(e.key).nodeType}class br{constructor(e,t){u(this,"_store",void 0),u(this,"_treeState",void 0),u(this,"_changes",void 0),u(this,"get",(e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!gr(e))throw a("Reading selectors within atomicUpdate is not supported");const t=mr(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;throw"hasError"===t.state?t.contents:a(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)})),u(this,"set",((e,t)=>{if(!gr(e))throw a("Setting selectors within atomicUpdate is not supported");if("function"==typeof t){const n=this.get(e);this._changes.set(e.key,t(n))}else hr(this._store,e.key,"set"),this._changes.set(e.key,t)})),u(this,"reset",(e=>{this.set(e,pr)})),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const e=yr(this._treeState);for(const[t,n]of this._changes)Sr(e,t,fr(n));return _r(this._store,e),e}}var Tr=function(e){return t=>{e.replaceState((n=>{const o=new br(e,n);return t(o),o.newTreeState_INTERNAL()}))}},Rr=Tr,wr=Object.freeze({__proto__:null,atomicUpdater:Rr});var Ar=function(e,t){if(!e)throw new Error(t)};const{atomicUpdater:Er}=wr,{batchUpdates:Nr}=Lt,{DEFAULT_VALUE:kr}=J,{useStoreRef:Vr}=Gn,{refreshRecoilValue:Lr,setRecoilValue:Mr}=lt,{Snapshot:Cr,cloneSnapshot:Ur}=un,{gotoSnapshot:Br}=or,{useCallback:Dr}=o;class Ir{}const Or=new Ir;function xr(e,t,n,o){let r=Or;return Nr((()=>{const s="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof t)throw a(s);const i=we({...null!=o?o:{},set:(t,n)=>Mr(e,t,n),reset:t=>Mr(e,t,kr),refresh:t=>Lr(e,t),gotoSnapshot:t=>Br(e,t),transact_UNSTABLE:t=>Er(e)(t)},{snapshot:()=>Ur(e)}),u=t(i);if("function"!=typeof u)throw a(s);r=u(...n)})),r instanceof Ir&&Ar(!1),r}var Pr={recoilCallback:xr,useRecoilCallback:function(e,t){const n=Vr();return Dr(((...t)=>xr(n.current,e,t)),null!=t?[...t,n]:void 0)}};const{useStoreRef:zr}=Gn,{refreshRecoilValue:Fr}=lt,{useCallback:Wr}=o;var $r=function(e){const t=zr();return Wr((()=>{const n=t.current;Fr(n,e)}),[e,t])};const{atomicUpdater:jr}=wr,{useStoreRef:Gr}=Gn,{useMemo:Hr}=o;var qr=function(e,t){const n=Gr();return Hr((()=>(...t)=>{jr(n.current)((n=>{e(n)(...t)}))}),null!=t?[...t,n]:void 0)};const Kr=(e,t,n)=>{var o;if(null==e)return;if(null==n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return Kr(e.branches.get(r),t,n)},Zr=(e,t,n,o,r,a,s)=>{var i;let u;if(null==e)if(0===t.length)u={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...i]=t,[c,l]=e;u={type:"branch",nodeKey:c,parent:n,branches:new Map,branchKey:r},u.branches.set(l,Zr(null,i,u,o,l,a,s))}else if(u=e,t.length){const[n,...r]=t,[i,c]=n;if("branch"!==e.type||e.nodeKey!==i)return W("Existing cache must have a branch midway through the route with matching node key. Resetting cache."),s(),u;e.branches.set(c,Zr(e.branches.get(c),r,e,o,c,a,s))}return null==a||null===(i=a.onNodeVisit)||void 0===i||i.call(a,u),u},Yr=(e,t,n)=>n?(n.branches.delete(t.branchKey),Jr(e,n,n.parent)):e===t,Jr=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),Jr(e,n,n.parent)):e===t,Xr=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+Xr(t)),0);var Qr=class{constructor(e){var t,n,o;u(this,"_numLeafs",void 0),u(this,"_root",void 0),u(this,"_onHit",void 0),u(this,"_onSet",void 0),u(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null==e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null==e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null==e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return Kr(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null==t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o,r=null;const a=()=>{r=Zr(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null==n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}},(()=>{this.clear(),a()}))};a(),this.root()||(this._root=r),this._numLeafs++,this._onSet(i(o))}delete(e){if(!this.root())return!1;const t=i(this.root());return!!Yr(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=Xr(e),!0))}clear(){this._numLeafs=0,this._root=null}},ea=Object.freeze({__proto__:null,TreeCache:Qr});var ta=class{constructor(e){var t;u(this,"_maxSize",void 0),u(this,"_size",void 0),u(this,"_head",void 0),u(this,"_tail",void 0),u(this,"_map",void 0),u(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=i(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},na=Object.freeze({__proto__:null,LRUCache:ta});const{LRUCache:oa}=na,{TreeCache:ra}=ea;var aa=function(e,t=(e=>e)){const n=new oa({maxSize:e}),o=new ra({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};function sa(e,t,n){if("string"==typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null==t?void 0:t.allowFunctions))throw a("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!=typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(s(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>sa(e,t,n.toString())))}]`;if("function"==typeof e.toJSON)return sa(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"==typeof n?n:sa(n,t)]=r;return sa(o,t,n)}return e instanceof Set?sa(Array.from(e).sort(((e,n)=>sa(e,t).localeCompare(sa(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"==typeof e[Symbol.iterator]?sa(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${sa(n,t)}:${sa(e[n],t,n)}`)).join(",")}}`}var ia=function(e,t={allowFunctions:!1}){return sa(e,t)};const{TreeCache:ua}=ea,ca={equality:"reference",eviction:"keep-all",maxSize:1/0};var la=function({equality:e=ca.equality,eviction:t=ca.eviction,maxSize:n=ca.maxSize}=ca){const o=function(e){switch(e){case"reference":return e=>e;case"value":return e=>ia(e)}throw a(`Unrecognized equality policy ${e}`)}(e),r=function(e,t,n){switch(e){case"keep-all":return new ua({mapNodeValue:n});case"lru":return aa(i(t),n);case"most-recent":return aa(1,n)}throw a(`Unrecognized eviction policy ${e}`)}(t,n,o);return r};const{isReactNative:da,isSSR:fa}=Ct;var ha={startPerfBlock:function(e){return()=>null}};const{loadableWithError:pa,loadableWithPromise:va,loadableWithValue:ya}=N,{getNodeLoadable:ma,peekNodeLoadable:_a,setNodeValue:Sa}=xe,{saveDependencyMapToStore:ga}=le,{DEFAULT_VALUE:ba,RecoilValueNotReady:Ta,getConfigDeletionHandler:Ra,getNode:wa,registerNode:Aa}=J,{isRecoilValue:Ea}=I,{markRecoilValueModified:Na}=lt,{retainedByOptionWithDefault:ka}=Tt,{recoilCallback:Va}=Pr,{startPerfBlock:La}=ha;class Ma{}const Ca=new Ma,Ua=[],Ba=new Map,Da=(()=>{let e=0;return()=>e++})();var Ia=function(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,u=null!=e.set?e.set:void 0,c=new Set,l=la(null!=r?r:{equality:"reference",eviction:"keep-all"}),d=ka(e.retainedBy_UNSTABLE),f=new Map;let h=0;function p(){return!z("recoil_memory_managament_2020")||h>0}function v(e){return e.getState().knownSelectors.add(n),h++,()=>{h--}}function y(){return void 0!==Ra(n)&&!p()}function m(e,t,n,o,r){C(t,o,r),T(e,t,new Set(r.keys()),n),_(e,n)}function _(e,n){M(e,n)&&L(e);const o=Ba.get(n);if(void 0!==o){for(const e of o)Na(e,i(t));Ba.delete(n)}}function S(e,t){let n=Ba.get(t);null==n&&Ba.set(t,n=new Set),n.add(e)}function g(e,t,n){const o=e.getState().knownSelectors.has(n);if(o&&t.atomValues.has(n))return i(t.atomValues.get(n));const r=ma(e,t,n);return"loading"!==r.state&&o&&t.atomValues.set(n,r),r}function b(e,t,n,o,r,a){return t.then((o=>{if(!p())throw L(e),Ca;null!=a.loadingDepKey&&a.loadingDepPromise===t?n.atomValues.set(a.loadingDepKey,ya(o)):e.getState().knownSelectors.forEach((e=>{n.atomValues.delete(e)}));const s=w(e,n);if(s&&"loading"!==s.state){if((M(e,r)||null==k(e))&&_(e,r),"hasValue"===s.state)return s.contents;throw s.contents}if(!M(e,r)){const e=E(n);if("loading"===(null==e?void 0:e.latestLoadable.state))return e.latestLoadable.contents}const[i,u]=R(e,n,r);if(V(e,r,u),"loading"!==i.state&&m(e,n,r,i,u),"hasError"===i.state)throw i.contents;return i.contents})).catch((t=>{if(t instanceof Ma)throw Ca;if(!p())throw L(e),Ca;const a=pa(t);throw m(e,n,r,a,o),t}))}function T(e,t,o,r){var a,s,i,u,l,d,f;(M(e,r)||t.version===(null===(a=e.getState())||void 0===a||null===(s=a.currentTree)||void 0===s?void 0:s.version)||t.version===(null===(i=e.getState())||void 0===i||null===(u=i.nextTree)||void 0===u?void 0:u.version))&&(ga(new Map([[n,o]]),e,null!==(l=null===(d=e.getState())||void 0===d||null===(f=d.nextTree)||void 0===f?void 0:f.version)&&void 0!==l?l:e.getState().currentTree.version),o.forEach((e=>c.add(e))))}function R(e,r,i){const u=La(n);let c=!0;const l=()=>{u(),c=!1};let d,f,h=!1;const v={loadingDepKey:null,loadingDepPromise:null},y=new Map,_=new Set;function S(t){const{key:n}=t;!function(e,t,n,o,r){n.add(o),T(e,t,n,r)}(e,r,_,n,i);const o=g(e,r,n);switch(y.set(n,o),o.state){case"hasValue":return o.contents;case"hasError":throw o.contents;case"loading":throw v.loadingDepKey=n,v.loadingDepPromise=o.contents,o.contents}throw a("Invalid Loadable state")}T(e,r,_,i);const R=n=>(...o)=>{if(c)throw a("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null==t&&Ar(!1),Va(e,n,o,{node:t})};try{d=o({get:S,getCallback:R}),d=Ea(d)?S(d):d,s(d)?d=function(e,t,n,o,r,a){return t.then((t=>{if(!p())throw L(e),Ca;const a=ya(t);return m(e,n,r,a,o),t})).catch((t=>{if(!p())throw L(e),Ca;if(V(e,r,o),s(t))return b(e,t,n,o,r,a);const i=pa(t);throw m(e,n,r,i,o),t}))}(e,d,r,y,i,v).finally(l):l()}catch(t){d=t,s(d)?d=b(e,d,r,y,i,v).finally(l):(h=!0,l())}return f=h?pa(d):s(d)?va(d):ya(d),[f,y]}function w(e,t){const o=new Set,r=k(e);let s;try{s=l.get((n=>{"string"!=typeof n&&Ar(!1);return g(e,t,n).contents}),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&o.add(e.nodeKey)}})}catch(e){throw a(`Problem with cache lookup for selector "${n}": ${e.message}`)}return s&&T(e,t,o,null==r?void 0:r.latestExecutionId),s}function A(e,t){const n=Da(),[o,r]=R(e,t,n);return"loading"===o.state?(!function(e,t,n,o,r){f.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:o,latestExecutionId:t,latestLoadable:n,stateVersion:r.version})}(e,n,o,r,t),S(e,n)):(L(e),C(t,o,r)),o}function E(e){var t;const[,n]=null!==(t=Array.from(f.entries()).find((([t,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=k(e),a=null!==(n=null==r?void 0:r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,s=Array((null!==(o=N.get(t.version))&&void 0!==o?o:new Map).entries()),i=N.has(t.version)&&s.length===a.size&&s.every((([e,t])=>a.get(e)===t));if(null==a||t.version===(null==r?void 0:r.stateVersion)||i)return!1;return N.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>g(e,t,n).contents!==o.contents))}(t,e))))&&void 0!==t?t:[];return n}const N=new Map;function k(e){return f.get(e)}function V(e,t,n){if(M(e,t)){const t=k(e);null!=t&&(t.depValuesDiscoveredSoFarDuringAsyncWork=n)}}function L(e){f.delete(e)}function M(e,t){var n;return t===(null===(n=k(e))||void 0===n?void 0:n.latestExecutionId)}function C(e,t,o){e.atomValues.set(n,t);try{l.set(function(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}(o),t)}catch(e){throw a(`Problem with setting cache for selector "${n}": ${e.message}`)}}function U(e,t){return l.get((n=>{var o;return"string"!=typeof n&&Ar(!1),null===(o=_a(e,t,n))||void 0===o?void 0:o.contents}))}function B(e,t){return function(e){if(Ua.includes(n)){const e=`Recoil selector has circular dependencies: ${Ua.slice(Ua.indexOf(n)).join("  ")}`;return pa(a(e))}Ua.push(n);try{return e()}finally{Ua.pop()}}((()=>function(e,t){const n=w(e,t);if(null!=n)return L(e),n;const o=E(t);var r;return null!=o?("loading"===(null===(r=o.latestLoadable)||void 0===r?void 0:r.state)&&S(e,i(o.latestExecutionId)),i(o.latestLoadable)):A(e,t)}(e,t)))}function D(e){e.atomValues.delete(n)}function I(e,n){null==t&&Ar(!1);for(const t of c){var o;const r=wa(t);null===(o=r.clearCache)||void 0===o||o.call(r,e,n)}c.clear(),D(n),l.clear(),Na(e,t)}if(null!=u){return t=Aa({key:n,nodeType:"selector",peek:U,get:B,set:(e,t,n)=>{let o=!1;const r=new Map;function i({key:n}){if(o)throw a("Recoil: Async selector sets are not currently supported.");const r=g(e,t,n);if("hasValue"===r.state)return r.contents;throw"loading"===r.state?new Ta(n):r.contents}function c(n,s){if(o)throw a("Recoil: Async selector sets are not currently supported.");const u="function"==typeof s?s(i(n)):s;Sa(e,t,n.key,u).forEach(((e,t)=>r.set(t,e)))}const l=u({set:c,get:i,reset:function(e){c(e,ba)}},n);if(void 0!==l)throw s(l)?a("Recoil: Async selector sets are not currently supported."):a("Recoil: selector set should be a void function.");return o=!0,r},init:v,invalidate:D,clearCache:I,shouldDeleteConfigOnRelease:y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}return t=Aa({key:n,nodeType:"selector",peek:U,get:B,init:v,invalidate:D,clearCache:I,shouldDeleteConfigOnRelease:y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})};const{loadableWithError:Oa,loadableWithPromise:xa,loadableWithValue:Pa}=N,{peekNodeInfo:za}=xe,{DEFAULT_VALUE:Fa,DefaultValue:Wa,getConfigDeletionHandler:$a,registerNode:ja,setConfigDeletionHandler:Ga}=J,{isRecoilValue:Ha}=I,{getRecoilValueAsLoadable:qa,markRecoilValueModified:Ka,setRecoilValue:Za,setRecoilValueLoadable:Ya}=lt,{retainedByOptionWithDefault:Ja}=Tt;function Xa(e){const{key:t,persistence_UNSTABLE:n}=e,o=Ja(e.retainedBy_UNSTABLE);let r,u=0,c=s(e.default)?xa(e.default.then((e=>(c=Pa(e),e))).catch((e=>{throw c=Oa(e),e}))):Pa(e.default);d(e.default);const l=new Map;function d(e){return e}function f(e,n){var o,a;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:r)&&void 0!==o?o:c}const h=ja({key:t,nodeType:"atom",peek:f,get:function(e,o){if(o.atomValues.has(t))return i(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return O(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),c;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,Fa),s=a instanceof Wa?c:Pa(a);return r=s,r}return c},set:function(e,n,o){if(n.atomValues.has(t)){const e=i(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof Wa)return new Map;return r=void 0,(new Map).set(t,Pa(o))},init:function(n,o,r){var i;if(u++,n.getState().knownAtoms.add(t),"loading"===c.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||Ka(n,h)};c.contents.finally(e)}const d=null!==(i=e.effects)&&void 0!==i?i:e.effects_UNSTABLE;if(null!=d){let e=!0,i=Fa,u=!1,y=null;function m(r){if(e&&r.key===t){const e=i;return e instanceof Wa?f(n,o):s(e)?xa(e.then((e=>e instanceof Wa?c.toPromise():e))):Pa(e)}return qa(n,r)}function _(e){return m(e).toPromise()}function S(o){var r;const a=za(n,null!==(r=n.getState().nextTree)&&void 0!==r?r:n.getState().currentTree,o.key);return!e||o.key!==t||i instanceof Wa?a:{...a,isSet:!0,loadable:m(o)}}const g=t=>o=>{if(e){const e=m(h),n="hasValue"===e.state?e.contents:Fa;i="function"==typeof o?o(n):o,s(i)&&(i=i.then((e=>(y={effect:t,value:e},e))))}else{if(s(o))throw a("Setting atoms to async values is not implemented.");"function"!=typeof o&&(y={effect:t,value:o}),Za(n,h,"function"==typeof o?e=>{const n=o(e);return y={effect:t,value:n},n}:o)}},b=e=>()=>g(e)(Fa),T=e=>o=>{var r;const{release:a}=n.subscribeToTransactions((n=>{var r;let{currentTree:a,previousTree:s}=n.getState();s||(W("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),s=a);const i=null!==(r=a.atomValues.get(t))&&void 0!==r?r:c;if("hasValue"===i.state){var u,l,d,f;const n=i.contents,r=null!==(u=s.atomValues.get(t))&&void 0!==u?u:c,h="hasValue"===r.state?r.contents:Fa;(null===(l=y)||void 0===l?void 0:l.effect)!==e||(null===(d=y)||void 0===d?void 0:d.value)!==n?o(n,h,!a.atomValues.has(t)):(null===(f=y)||void 0===f?void 0:f.effect)===e&&(y=null)}}),t);l.set(n,[...null!==(r=l.get(n))&&void 0!==r?r:[],a])};for(const e of d)try{const t=e({node:h,storeID:n.storeID,trigger:r,setSelf:g(e),resetSelf:b(e),onSet:T(e),getPromise:_,getLoadable:m,getInfo_UNSTABLE:S});var p;if(null!=t)l.set(n,[...null!==(p=l.get(n))&&void 0!==p?p:[],t])}catch(e){i=e,u=!0}if(e=!1,!(i instanceof Wa)){var v;const e=i,r=u?Oa(i):s(e)?xa(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Za(e,h,n),n})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Ya(e,h,Oa(n)),n}));return o}(n,e)):Pa(e);o.atomValues.set(t,r),null===(v=n.getState().nextTree)||void 0===v||v.atomValues.set(t,r)}}return()=>{var e;u--,null===(e=l.get(n))||void 0===e||e.forEach((e=>e())),l.delete(n)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==$a(t)&&u<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return h}function Qa(e){const{default:t,...n}=e;return Ha(t)?function(e){const t=Qa({...e,default:Fa,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof Wa?t:i(e.persistence_UNSTABLE).validator(t,Fa)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=Ia({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof Wa?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Ga(n.key,$a(e.key)),n}({...n,default:t}):Xa({...n,default:t})}var es=Qa;var ts=class{constructor(e){var t;u(this,"_map",void 0),u(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null==e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},ns=Object.freeze({__proto__:null,MapCache:ts});const{LRUCache:os}=na,{MapCache:rs}=ns,as={equality:"reference",eviction:"none",maxSize:1/0};var ss=function({equality:e=as.equality,eviction:t=as.eviction,maxSize:n=as.maxSize}=as){const o=function(e){switch(e){case"reference":return e=>e;case"value":return e=>ia(e)}throw a(`Unrecognized equality policy ${e}`)}(e),r=function(e,t,n){switch(e){case"keep-all":return new rs({mapKey:n});case"lru":return new os({mapKey:n,maxSize:i(t)});case"most-recent":return new os({mapKey:n,maxSize:1})}throw a(`Unrecognized eviction policy ${e}`)}(t,n,o);return r};const{setConfigDeletionHandler:is}=J;var us=function(e){var t,n;const o=ss({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n,r;const a=o.get(t);if(null!=a)return a;const{cachePolicyForParams_UNSTABLE:s,...i}=e,u=es({...i,key:`${e.key}__${null!==(n=ia(t))&&void 0!==n?n:"void"}`,default:"function"==typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects:"function"==typeof e.effects?e.effects(t):"function"==typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):null!==(r=e.effects)&&void 0!==r?r:e.effects_UNSTABLE});return o.set(t,u),is(u.key,(()=>{o.delete(t)})),u}};const{setConfigDeletionHandler:cs}=J;let ls=0;var ds=function(e){var t,n;const o=ss({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(n=ia(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${ls++}`,s=n=>e.get(t)(n),i=e.cachePolicy_UNSTABLE,u="function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let c;if(null!=e.set){const n=e.set;c=Ia({key:a,get:s,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else c=Ia({key:a,get:s,cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return o.set(t,c),cs(c.key,(()=>{o.delete(t)})),c}};const fs=ds({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var hs=function(e){return fs(e)};const ps=ds({key:"__error",get:e=>()=>{throw a(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var vs=function(e){return ps(e)};var ys=function(e){return e};const{loadableWithError:ms,loadableWithPromise:_s,loadableWithValue:Ss}=N;function gs(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(e){o[r]=e}return[n,o]}function bs(e){return null!=e&&!s(e)}function Ts(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function Rs(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function ws(e,t,n){return Rs(e,n.map(((e,n)=>null==e?Ss(t[n]):s(e)?_s(e):ms(e))))}var As={waitForNone:ds({key:"__waitForNone",get:e=>({get:t})=>{const n=Ts(e),[o,r]=gs(t,n);return ws(e,o,r)},dangerouslyAllowMutability:!0}),waitForAny:ds({key:"__waitForAny",get:e=>({get:t})=>{const n=Ts(e),[o,r]=gs(t,n);return r.some((e=>!s(e)))?ws(e,o,r):new Promise((t=>{for(const[n,a]of r.entries())s(a)&&a.then((a=>{o[n]=a,r[n]=void 0,t(ws(e,o,r))})).catch((a=>{r[n]=a,t(ws(e,o,r))}))}))},dangerouslyAllowMutability:!0}),waitForAll:ds({key:"__waitForAll",get:e=>({get:t})=>{const n=Ts(e),[o,r]=gs(t,n);if(r.every((e=>null==e)))return Rs(e,o);const a=r.find(bs);if(null!=a)throw a;return Promise.all(r).then((t=>{return Rs(e,(n=o,t.map(((e,t)=>void 0===e?n[t]:e))));var n}))},dangerouslyAllowMutability:!0}),waitForAllSettled:ds({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Ts(e),[o,r]=gs(t,n);return r.every((e=>!s(e)))?ws(e,o,r):Promise.all(r.map(((e,t)=>s(e)?e.then((e=>{o[t]=e,r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>ws(e,o,r)))},dangerouslyAllowMutability:!0}),noWait:ds({key:"__noWait",get:e=>({get:t})=>{try{return Ss(t(e))}catch(e){return s(e)?_s(e):ms(e)}},dangerouslyAllowMutability:!0})};const{RecoilLoadable:Es}=N,{DefaultValue:Ns}=J,{RecoilRoot:ks,useRecoilStoreID:Vs}=Gn,{isRecoilValue:Ls}=I,{retentionZone:Ms}=be,{freshSnapshot:Cs}=un,{useRecoilState:Us,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Bs,useRecoilStateLoadable:Ds,useRecoilValue:Is,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Os,useRecoilValueLoadable:xs,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Ps,useResetRecoilState:zs,useSetRecoilState:Fs}=Io,{useGotoRecoilSnapshot:Ws,useRecoilSnapshot:$s,useRecoilTransactionObserver:js}=or,{useRecoilCallback:Gs}=Pr,{noWait:Hs,waitForAll:qs,waitForAllSettled:Ks,waitForAny:Zs,waitForNone:Ys}=As;var Js={DefaultValue:Ns,isRecoilValue:Ls,RecoilLoadable:Es,RecoilRoot:ks,useRecoilStoreID:Vs,useRecoilBridgeAcrossReactRoots_UNSTABLE:dr,atom:es,selector:Ia,atomFamily:us,selectorFamily:ds,constSelector:hs,errorSelector:vs,readOnlySelector:ys,noWait:Hs,waitForNone:Ys,waitForAny:Zs,waitForAll:qs,waitForAllSettled:Ks,useRecoilValue:Is,useRecoilValueLoadable:xs,useRecoilState:Us,useRecoilStateLoadable:Ds,useSetRecoilState:Fs,useResetRecoilState:zs,useGetRecoilValueInfo_UNSTABLE:sr,useRecoilRefresher_UNSTABLE:$r,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Ps,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Os,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Bs,useRecoilCallback:Gs,useRecoilTransaction_UNSTABLE:qr,useGotoRecoilSnapshot:Ws,useRecoilSnapshot:$s,useRecoilTransactionObserver_UNSTABLE:js,snapshot_UNSTABLE:Cs,useRetain:oo,retentionZone:Ms},Xs=Js.DefaultValue,Qs=Js.RecoilRoot,ei=Js.atom,ti=Js.selector,ni=Js.useRecoilValueLoadable,oi=Js.useRecoilState,ri=Js.useSetRecoilState}}]);