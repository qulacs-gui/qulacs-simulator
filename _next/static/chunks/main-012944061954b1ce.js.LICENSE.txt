/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/

/* (ignored) */

/* ["default"] */

/*#__PURE__*/

/**
             * We should only trigger a server-side transition if this was
             * caused on a client-side transition. Otherwise, we'd get into
             * an infinite loop.
             */

/**
             * When the data response is a redirect because of a middleware
             * we do not consider it an error. The headers must bring the
             * mapped location.
             * TODO: Change the status code in the handler.
             */

/**
     * If there is a redirect to an external destination then we don't have
     * to prefetch content as it will be unused.
     */

/**
     * If there was a rewrite we apply the effects of the rewrite on the
     * current parameters for the prefetch.
     */

/**
     * TODO: Revisit this in the future.
     * For now we will not consider middleware data errors to be fatal.
     * maybe we should revisit in the future.
     */

/**
     * This `route` binding can change if there's a rewrite
     * so we keep a reference to the original requested route
     * so we can store the cache for it and avoid re-requesting every time
     * for shallow routing purposes.
     */

/**
   * Callback to execute before replacing router state
   * @param cb callback to be executed
   */

/**
   * Go back in history
   */

/**
   * Go forward in history
   */

/**
   * Performs a `pushState` with arguments
   * @param url of the route
   * @param as masks `url` for the browser
   * @param options object you can define `shallow` and other options
   */

/**
   * Performs a `replaceState` with arguments
   * @param url of the route
   * @param as masks `url` for the browser
   * @param options object you can define `shallow` and other options
   */

/**
   * Prefetch page code, you may wait for the data during page rendering.
   * This feature only works in production!
   * @param url the href of prefetched page
   * @param asPath the as path of the prefetched page
   */

/**
   * this used to be previously:
   *
   * `return prototype === null || prototype === Object.prototype`
   *
   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.
   *
   * It was changed to the current implementation since it's resilient to serialization.
   */

/**
 *
 * @param headChildrenElements List of children of <Head>
 */

/**
 * Builds a function to generate a minimal routeKey using only a-z and minimal
 * number of characters.
 */

/**
 * Getter for the Trusted Types Policy. If it is undefined, it is instantiated
 * here or set to null if Trusted Types is not supported in the browser.
 */

/**
 * Parses a given parameter from a route to a data structure that can be used
 * to generate the parametrized route. Examples:
 *   - `[...slug]` -> `{ name: 'slug', repeat: true, optional: true }`
 *   - `[foo]` -> `{ name: 'foo', repeat: false, optional: true }`
 *   - `bar` -> `{ name: 'bar', repeat: false, optional: false }`
 */

/**
 * Stores the Trusted Types Policy. Starts as undefined and can be set to null
 * if Trusted Types is not supported in the browser.
 */

/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */

/**
 * `App` component is used for initialize of pages. It allows for overwriting and full control of the `page` initialization.
 * This allows for keeping state between navigation, custom error handling, injecting additional data.
 */

/**
 * transforms the ParsedUrlQuery into a URLSearchParams.
 *
 * @param query the query to transform
 * @returns URLSearchParams
 */

/** Execute after the script first loaded */

/** the route (file-system path) */

/******/

/***/

//

//    browser begins to fetch.

//    executes when `src` is set.

//    must be appended for fetching to start.

//  1. Page doesn't exists

//  1. With older safari (< 8) and older chrome (< 34)

//  2. Page does exist in a different zone

//  2. When the URL changed with #

//  3. Internal error while loading the page

// (as it's already changed)

// (not location.reload() but reload getInitialProps and other Next.js stuffs)

// - if it is a client-side skeleton (fallback render)

// - if middleware matches the current page (may have rewrite params)

// - if rewrites in next.config.js match (may have rewrite params)

// - it was auto exported and is a dynamic route (to provide params)

// - the page was (auto) exported and has a query string or search (hash)

// 1. Setup success/failure hooks in case the browser synchronously

// 2. Configure the cross-origin attribute before setting `src` in case the

// 3. Finally, set the source and inject into the DOM in case the child

// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive

// 404 and 500 errors are special kind of errors

// > For maximum browser compatibility when it comes to sending &

// > `fetch` won’t send cookies, unless you set the credentials init

// > option instead of relying on the default.

// > option.

// > receiving cookies, always supply the `credentials: 'same-origin'`

// @ts-ignore

// @ts-ignore internal value not exposed on types

// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3

// Actually, for (1) we don't need to nothing. But it's hard to detect that event.

// Add this attribute to make it easy to identify optimized tags

// Adds support for React.Fragment

// And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities

// Backwards compat for Router.router.events

// Before interactive scripts need to be loaded by Next.js' runtime instead

// Both are fine because `pages/[post]` and `pages/blog` are on the same level

// But we can simply replace the state with the new changes.

// Changing the URL doesn't block executing the current code path.

// Check again the cache with the new destination.

// Check if the segment matches `[something]`

// Check only path match on client. Matching "has" should be done on server

// Combines timestamp with random number for unique ID

// Contents of this script are already loading/loaded

// Context is available only during SSR

// Cookies are required to be present for Next.js' SSG "Preview Mode".

// Cookies may also be required for `getServerSideProps`.

// Create public properties and methods of the router in the singletonRouter

// Decode hash to make non-latin anchor works.

// Defer page registration for another tick. This will increase the overall

// Do not cache RSC flight response since it's not a static resource

// Dummy component that we render as a child of Root so that we can

// Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js

// Ensure this render was not canceled

// Events is a static property on the router, the router doesn't have to be initialized to use it

// Every time the path changes, announce the new page’s title following this

// Fall back to reading the values from the href

// Fallback pages must trigger the data fetch, so the transition is

// Finally, clean up server rendered stylesheets:

// First the UrlNode is created, and every UrlNode can have only 1 dynamic segment

// First we check if the element by id is found

// For inlined scripts, we put the content in `children`.

// For non-SSG prefetches that bailed before sending data

// For the app directory, we need React Float to preload these scripts.

// Here the `root` gets injected multiple paths, and insert will break them up into sublevels

// Here we need to use Object.defineProperty because we need to return

// Identify /[param]/ in route string

// If asked to change the current URL we should reload the current page

// If the downstream application returns falsy, return.

// If the path hasn't change, we do nothing.

// If the routeInfo brings a redirect we simply apply it.

// If the url change is only related to a hash change

// If the urls are change, there's more than a hash change

// If there's no element with the id, we check the `name` property

// If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode

// If url and as provided as an object representation,

// If we call scrollIntoView() in here without a setTimeout

// If we can't load the page it could be one of following reasons

// If we fail to resolve the page list or client-build manifest, we must

// If we have a match with the current route due to rewrite,

// If we've gotten here upon initial render, we can use the props from the server.

// In Chrome-based browsers we need to force reflow before calling `scrollTo`.

// In development runtime errors are caught by our overlay

// In production we catch runtime errors using componentDidCatch which will trigger renderError

// In production we do a normal render with the `ErrorComponent` as component.

// In the both cases, we don't need to proceed and change the route.

// Initialize next/config with the environment configuration

// Instead what has to be passed through is the upwards path's dynamic names

// Interpolate group into data URL if present

// It is possible that multiple `next/script` components all have same "src", but has different "onLoad"

// It may change at any time without notice.

// JavaScript bundle unless explicitly enabled in your application.

// License: Apache 2.0

// Make sure we don't re-render on initial load,

// Makes sure we scroll to the provided hash if the url/hash are the same

// Mandatory because this is not concurrent safe:

// Merge params into `query`, overwriting any specified in search

// More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042

// No prefetches for bots that render the link since they are typically navigating

// On initial render a hydrate should always happen

// Only 1 dynamic segment per nesting level

// Only bust the data cache for SSP routes although

// Only register listeners once:

// Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not

// Other pages (strictly updating query) happens shallowly, as data

// Otherwise it will not pickup the change in scrollBehavior

// Otherwise, this cause issues when when going back and

// Otherwise, we need to call `getInitialProps` on `App` before mounting.

// Passing the empty string here should be safe against future changes to the method.

// Promise. It should remain synchronous.

// React children can be "string" or "number" in this case we ignore them for backwards compat

// Reorder styles into intended order:

// Resolve a promise that times out after given amount of milliseconds.

// Resolved, cancel the timeout

// Return because it cannot be routed by the Next.js router

// Run onReady for the first time after load event

// Run onReady if script has loaded before but component is re-mounted

// Safari fires popstateevent when reopening the browser.

// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1

// Script has already loaded

// Script has already loaded during SSR

// Scroll to top if the hash is just `#` with no value or `#top`

// Server Background Cache (HEAD requests)

// Server Data Cache (full data requests)

// Skip certain custom errors which are not expected to be reported on client

// Skip executing script if it's already in the DOM:

// Smoosh will then sort those sublevels up to the point where you get the correct route definition priority

// So in the case that is test/integration/dynamic-routing it'll be this:

// So in this case `UrlNode` created here has `this.slugName === 'post'`

// So let's throw a cancellation error stop the routing logic.

// So, doing a hard reload is the proper way to deal with this.

// So, doing the following for (1) does no harm.

// So, this is how we do it in the client side at runtime

// Strip `...`, leaving only `something`

// Strip `[` and `]`, leaving only `something`

// Strip optional `[` and `]`, leaving only `something`

// TODO(prateekbh@): Replace this with const from `constants` when the tree shaking works.

// TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing

// TODO: Should be remove the following major version as it was never documented

// TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.

// TODO: do we need the resolved href when only a hash change?

// TODO: more robust handling for user-error (passing `/`)

// TODO: should this take priority; also need to change in the router.

// The `router.asPath` contains the pathname seen by the browser (including

// The next segment in the urlPaths list

// The order of property assignment here is intentional.

// The order of property assignment here is intentional:

// The value might get changed as we change routes and this is the

// Then, we return the information along with the matched route.

// They will then be responsible for handling the event.

// This catches errors like throwing in the top level of a module

// This code is not shipped, executed, or present in the client-side

// This function has a return type to ensure it doesn't start returning a

// This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`

// This is to make sure the same remote script will only load once, but "onLoad" are executed in order

// This method handles all runtime and debug errors.

// To mirror browsers

// Toggle `<style>` tags on or off depending on if they're needed:

// URL as this can end up with an infinite refresh

// Unlike with createRoot, you don't need a separate root.render() call here

// Update function if it changes:

// Use the destination from redirect without adding locale

// Using default react onRecoverableError

// WARNING: `_h` is an internal option for handing Next.js

// WARNING: `_h` is an internal option for handing Next.js client-side

// We also need to set the method = replaceState always

// We can skip this during hydration. Running it wont cause any harm, but

// We catch runtime errors using componentDidCatch which will trigger renderError

// We get state as undefined for two reasons.

// We need to call `updateHead` method whenever the `SideEffect` is trigger in all

// We need to replace the router state if:

// We should ask to measure the Web Vitals after rendering completes so we

// We should compare the new asPath to the current asPath, not the url

// We should not keep the cache, if there's an error

// We should not proceed. We should only change the state.

// We use `useLayoutEffect` to guarantee the callback is executed

// We use `useLayoutEffect` to guarantee the callbacks are executed

// We wait for pages to be built in dev before we start the route transition

// When `isAutoExport` is true, meaning this is a page page has been

// When the page being rendered is the 404 page, we should only update the

// When the route is a dynamic route, we need to do more processing to

// When the router is rendering the fallback page, it can't possibly know

// When this feature is enabled, we'll make it very clear by printing a

// With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time

// __NA is used to identify if the history entry can be handled by the app-router.

// `asPath` option over at:

// `href` should always be last:

// absolute urls can be local if they are on the same origin

// add cacheKey to LoadCache when load successfully

// and they are still handle via the main render method.

// any query strings), so it should have that stripped. Read more about the

// any time without notice.

// as it's un-necessary and doesn't need to be fatal

// as soon as React flushes the update

// as soon as React flushes the update.

// as this should not go into the history (That's how browsers work)

// at:

// automatically statically optimized, and the router is not ready, then

// back from external site

// basePath from the pathname to match the pages dir 1-to-1

// be loaded

// be stripped if there is no content security policy response header that includes a nonce.

// being rendered, we only trigger the method from the last one.

// below `changeState` call which updates the browser's history (changing

// bubble up cancelation errors

// bubble up cancellation errors

// cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)

// can be caused by navigating back from an external site

// can be returned and this should trigger a hard navigation

// check if destination is internal (resolves to a page) and attempt

// check if the key is still invalid and fallback to using a known

// client-navigation if it is falling back to hard navigation if

// client-side hydration. Your app should _never_ use this property.

// client-transition a redirect that doesn't match a page

// come again to the errored page.

// considers as "Good" time-to-interactive. We must assume something went

// copied to prevent pulling in un-necessary utils

// determine if we need to stop showing the pathname.

// do a server-side transition:

// do not add cacheKey into LoadCache for remote script here

// don't cause any hydration delay:

// during query updating the page must match although during

// ensure statusCode is still correct for static 500 page

// ensure we don't trigger a hard navigation to the same

// eslint-disable-next-line @typescript-eslint/no-use-before-define

// eslint-disable-next-line array-callback-return

// eslint-disable-next-line default-case

// fallback to / for invalid asPath values e.g. //

// firefox

// first item will be empty string from splitting at first char

// for static pages with query params in the URL we delay

// handle SSG data 404

// handle redirect on client-transition

// handle resolving href for dynamic routes

// https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch

// https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState

// https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118

// https://github.com/github/fetch#caveats

// https://medium.com/@jessebeach/beware-smushed-off-screen-accessible-text-5952a4c2cbfe

// https://nextjs.org/docs/advanced-features/automatic-static-optimization

// https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-pages

// https://nextjs.org/docs/api-reference/next/router#router-object

// https://www.gatsbyjs.com/blog/2019-07-11-user-testing-accessible-client-routing/

// hydration. Your app should _never_ use this property. It may change at

// if a route transition is already in progress before

// if auto prerendered and dynamic route wait to update asPath

// if none of these exist, then the pathname from the URL. This methodology is

// if the origin didn't change, it means we received a relative href

// in order for `e.state` to work on the `onpopstate` event

// inflight cache until successful data response

// information can be found here:

// inspired by Marcy Sutton’s accessible client routing user testing. More

// into the URL and we expect URL encoded segments

// invalid and will never match a Next.js page/file

// isAutoExport is only ever `true` on the first render from the server,

// it won't be inlined. In this case revert to the original behavior

// it won't scroll properly.

// it's not

// lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.

// latency in hydrating the page, but reduce the total blocking time.

// leverage x-matched-path to detect next.config.js rewrites

// life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s

// links via the equivalent of a hard navigation and hence never utilize these

// make sure "as" doesn't start with double slashes or else it can

// make sure not to attempt stripping basePath for 404s

// make sure to ignore extra popState in safari on navigating

// mark end of render

// mark start of hydrate/render

// marking route changes as a navigation start entry

// marking the router ready until after the query is updated

// message during the build (`next build`).

// middleware can skip cache per request with

// nextSegment is overwritten to [...] so that it can later be sorted specifically

// nextSegment is overwritten to [[...]] so that it can later be sorted specifically

// nextSegment is overwritten to [] so that it can later be sorted specifically

// not shallow.

// of native <script> tags, because they no longer have `defer`.

// optimization at:

// or a navigation has occurred

// pages to allow building the data URL correctly

// pages/[post]/comments.js

// pages/blog/[post]/comment/[id].js

// path delimiter escaped since they are being inserted

// point by either next/link or router.push/replace so strip the

// prefetches.

// prevent a hydration mismatch on href for url with anchor refs

// priority: first the document title (from head), otherwise the first h1, or

// proper way to access it

// query parameters. Route changes here might add the basePath when it

// regexp is based on https://github.com/sindresorhus/escape-string-regexp

// remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`

// repeated slashes and backslashes in the URL are considered

// replace any non-word characters since they can break

// represents the current component key

// requirements would already be present.

// router is initialized later so it has to be live-binded

// safari

// safe key

// see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23

// set up the component cache (by route keys)

// shallow routing is only allowed for same page URL changes.

// show the user something of value.

// singleton in the layout effect pass, and actually trigger it in the effect pass.

// slugName is kept as it can only be one particular slugName

// so reset it to `false` after we read it for the first time as `true`. If

// support single-level catch-all

// the URL).

// the named regex

// the path, so return `null` here. Read more about fallback pages over

// the property assigned to the actual router

// the query updating is triggered ignore query updating

// the route is outdated and we want to invalidate

// this allows racing click event with fetching newer data

// this cache entry

// throw an error as it's considered invalid

// timeout to prevent an un-necessary hard navigation in development.

// toggle the correct styles before the page is rendered.

// unless it is a fallback route and the props can't

// unless we're in production:

// until after mount to prevent hydration mismatch

// update query on mount for exported pages

// url and as should always be prefixed with basePath by this

// wasn't originally present. This is also why this block is before the

// we can copy the existing information to the rewritten one.

// we can't know the pathname yet. Read more about automatic static

// we clear the cache to fetch full response

// we don't hard error during query updating

// we don't render undefined props to the DOM

// we don't use the value, then we don't need it.

// we don't want to cache errors during prefetch

// we have to register the initial route upon initialization

// we kick off a HEAD request in the background

// we may as well save the CPU cycles:

// we need to resolve the as value using rewrites for dynamic SSG

// we use a dummy base url for relative urls

// we'll format them into the string version here.

// when a non-prefetch request is made to signal revalidation

// when called from _app `ctx` is nested in `ctx`

// when parsing dynamic route params

// when skipping client cache we wait to update

// when this entrypoint has been resolved before

// when updating query information

// where we can access more info such as headers, HttpOnly cookie, etc.

// which is valid for incremental migration

// with relList.support

// without blocking navigation when stale data is available

// wrong beyond this point, and then fall-back to a full page transition to

// x-middleware-cache: no-cache as well

// x-ref: https://github.com/facebook/react/blob/d4bc16a7d69eb2ea38a88c8ac0b461d5f72cdcab/packages/react-dom/src/client/ReactDOMRoot.js#L83

//# sourceMappingURL=adapters.js.map

//# sourceMappingURL=add-base-path.js.map

//# sourceMappingURL=add-locale.js.map

//# sourceMappingURL=add-path-prefix.js.map

//# sourceMappingURL=add-path-suffix.js.map

//# sourceMappingURL=amp-mode.js.map

//# sourceMappingURL=compare-states.js.map

//# sourceMappingURL=denormalize-page-path.js.map

//# sourceMappingURL=escape-regexp.js.map

//# sourceMappingURL=format-next-pathname-info.js.map

//# sourceMappingURL=format-url.js.map

//# sourceMappingURL=get-asset-path-from-route.js.map

//# sourceMappingURL=get-next-pathname-info.js.map

//# sourceMappingURL=has-base-path.js.map

//# sourceMappingURL=index.js.map

//# sourceMappingURL=is-api-route.js.map

//# sourceMappingURL=is-bot.js.map

//# sourceMappingURL=is-dynamic.js.map

//# sourceMappingURL=is-error.js.map

//# sourceMappingURL=is-plain-object.js.map

//# sourceMappingURL=mitt.js.map

//# sourceMappingURL=normalize-locale-path.js.map

//# sourceMappingURL=normalize-path-sep.js.map

//# sourceMappingURL=on-recoverable-error.js.map

//# sourceMappingURL=parse-path.js.map

//# sourceMappingURL=parse-relative-url.js.map

//# sourceMappingURL=path-has-prefix.js.map

//# sourceMappingURL=querystring.js.map

//# sourceMappingURL=remove-base-path.js.map

//# sourceMappingURL=remove-locale.js.map

//# sourceMappingURL=remove-path-prefix.js.map

//# sourceMappingURL=remove-trailing-slash.js.map

//# sourceMappingURL=route-loader.js.map

//# sourceMappingURL=route-matcher.js.map

//# sourceMappingURL=route-regex.js.map

//# sourceMappingURL=sorted-routes.js.map

//# sourceMappingURL=with-router.js.map
